1. 컴파일의 개념 (Library, Path 및 IDE의 환경 설정에 대한 기본 개념) 
 컴파일이란 프로그래밍 언어를 기계가 해독할 수 있는 언어(기계어)로 변환하는 과정이다
(코드 전체)
인터프리트 는 코드를 한줄 씩 번역하여 실행하는 것 컴파일을 해주는 프로그램은  컴파일러
인터프리트를 해주는 프로그램은 인터프리터이다.

●IDE
통합 개발 환경은 Integrated Development Environment의 약어로 흔히 IDE라 부른다.

이는 코딩, 디버깅, 컴파일, 배포 등 프로그램 개발에 관련된 모든 작업을 하나의 프로그램 안에서 처리하는 환경을 제공하는 일종의 개발용 소프트웨어이다.

기존 소프트웨어 개발은 콘솔창이나 터미널을 통해 개발하고 컴파일러, 텍스트 편집기, 디버거 등을 따로 사용하였다.

그러나 이러한 프로그램들을 하나로 묶어 대화형 인터페이스를 제공한 것이 통합 개발 환경이다. 대표적인 IDE로는 이클립스, 비쥬얼 베이직 등이 있다.

●Library

-자주 사용되는 기능(함수, 변수 등)을 모듈화 한 것 
-jar파일로 구성
-api는 라이브러리를 사용할 수 있도록 소스코드 수준에서 인터페이스를 노출시킨 것
 (Application Programming Interface)

?표준 라이브러리 : 특정 언어의 개발 환경에 기본적으로 포함된 것들은 대부분 표준 라이브러리라고 불린다. 기본적인 기능 수행과 더불어 디버깅, 성능측정 등을 위한 별도의 API가 존재한다.
?런타임 라이브러리 : 프로그램이 실제 환경에서 실행되기 위해 필요한 모듈들이다. 대부분 위의 표준 라이브러리에서 기능 수행에 필요한 것들만 제공되거나, 스크립트의 실행기 등을 말한다.

라이브러리를 사용 할 때 라이센스가 있는지 확인해야한다. 구매를 해야지 사용할 수 있는 라이브러리가 있고 판매를 목적으로 하는 프로그램에만 돈을 요구하는 라이브러리도 있다.
대표적으로는 jqeury, jomi 등이 있다.

●PATH
특정 파일을 찾기 위해 경로를 지정해 주는 것이 path 이다.
패스는 파일이 아닌, '환경 변수 (environment variable)'라는 메모리에 저장된다.
대부분 해봤던 환경변수 설정이 이것이다 java_home을 jdk경로로 맞추는 것이 이것이다.
물론 환경변수 말고도 path를 이용하는 예는 많다. 이클립스를 수행할 때 라이브러리를 추가하는 java build path등이 있다. 대부분 콘솔이나 터미널 환경에서는 path를 정확히 명시해줘야 프로그램이 실행된다.


2. mvc 1, 2 구조의 기초
Model , View , Controller 의 합성어로 프로그램에 사용되는 소프트웨어 디자인 패턴

Model : 백그라운드에서 동작하는 로직을 처리

View : 사용자가 보게 될 결과 화면을 출력

Controller : 사용자의 입력처리와 흐름 제어를 담당

모델1


모델1 구조는 사용자의 요청을 JSP가 전부 다 처리한다. 웹브라우저 사용자의 요청을 받은 JSP는 자바빈이나 서비스 클래스를 사용하여 웹브라우저가 요청한 작업을 처리하고 그 결과를 출력한다.

모델2



모델 2 구조는 모델 1구조와 달리 웹브라우저 사용자의 요청을 서블릿이(control) 받는다. 서블릿은 웹브라우저의 요청을 받아 View로 보여줄것인지 Model로 보내줄것인지 정하여 전송하는데 여기서 View페이지는 사용자에게 보여주는 역할만 담당하고 실질적인 기능의 부분은 Model에서 담당한다. 모델2 방식의 경우 실질적으로 보여지는 HTML과 JAVA 소스를 분리 해놓았기 때문에 모델1방식에 비해 개발을 확장시키기도 쉽고 유지보수하기도 쉽다.

3. 클래스와 인스턴스 그리고 패키지의 기본 개념
●클래스 와 인스턴스
객체 지향 프로그래밍에서 특정 객체를 생성하기 위해 변수와 메소드를 정의하는 일종의 틀
변수와 메서드로 구성되어있다.
객체에 대한 설계도를 클래스라고 한다면 클래스에서 만들어지는  객체는 인스턴스이다.
(붕어빵 기계가 클래스이고 나오는 객체(인스턴스)는 붕어빵)
이렇게 클래스를 정의하고 인스턴스를 생성하는 이유는 예를 들어서 슈팅게임에서 총알이라는 객체는 많이 필요해서 클래스라는 틀에서 바로 인스턴스가 생성되는 것이 편리하다.
클래스의 각 변수는 객체의 속성, 메소드는 객체가 수행할 기능을 정의 해놓은 것이다.
각 인스턴스를 생성할 때 마다. 생성자를 호출해서 생성한다.
class name= new name();


●패키지
서로 관련된 클래스끼리 그룹단위로 묶어놓은 것 클래스가 물리적으로 하나의 클래스파일(.class)이지만 패키지는 그 클래스들을 모아노은 하나의 디렉토리이다. 
패키지는 폴더와 유사하다. 클래스가 많아짐에 따라서 같은 이름을 가진 클래스가 생겨날 가능성이 높아지게 되는데 이름의 충돌을 방지하기 위한 고안된 것이 패키지라고 할 수 있다.

모든 클래스는 패키지에 속해있어야 하고 선언하지 않을 경우 unnamed package 에 속한다.
선언방법 
pakage pakage_name;

만약 다른 패키지의 클래스를 사용하기 위해서는 import 문을 사용해 클래스를 선언해 주면 사용 가능하다.
import 사용 방법
import java.io.FileInputStream;
import java.util.Scanner;

4. 접근제어 지시자와 정보은닉, 캡슐화 
●접근제어 지시자
클래스, 메소드, 변수를 선언할 때 앞에 붙는 수식이 있는데 public, protected, private 가 바로 접근제어 지시자 이다.
이 지시자를 통해 메소드, 클래스 등에 대해 접근을 허용하는 범위를 지정하는 것이 바로 이 접근 제어 지시자이다,
이런 접근제어는 왜 사용하는 이유는 클래스 안의 변수나 메소드들은 접근 연산자(.) 로 접근이 가능한데 밖으로 나가서는 안되는 정보이거나 조작이 민감한 변수들에 대해서 스코프를 제한하는 것이다. 일종의 정보은닉의 일종이다.

private
클래스내부 o
동일패키지 x
상속받은 클래스 x
이외의 영역 x
default
클래스내부 o
동일패키지 o
상속받은 클래스 x
이외의 영역 x
protected
클래스내부 o
동일패키지 o
상속받은 클래스 o
이외의 영역 x
public
클래스내부 o
동일패키지 o
상속받은 클래스 o
이외의 영역 o


위 표는 각 접근제어 지시자의 유효 범위를 나타낸 것이다. 
private는 클래스 내부에서만 사용되고
default는 지시자를 쓰지 않았을 때이다 이때는 클래스, 동일 패키지 내에서 사용 가능하다.
protected는 동일패키지, 상속받은 상위의 클래스까지 사용 가능하다.
public은 어디서든지 접근이 가능하다.


●정보은닉과 캡슐화

정보은닉은 모든 객체지향 언어적 요소를 활용하여 객체에 대한 구체적인 정보를 노출시키지 않도록 하는 기법이라고 할 수있다.
대부분의 사람들이 정보은닉과 캡슐화를 같은 개념으로 생각하는 경우가 많다
하지만 데이터를 공용 메소드를 통해서만 접근하도록 허용하는 방법을 데이터 캡슐화라고 하며 정보 은닉과 데이터 캡슐화는 동일한 개념이 아니다.
정보 은닉은 외부에 감추어야 하는 비밀에 따라 시스템을 분할하는 모듈 분할의 원리이다.
정보은닉에는 여러 가지 방법이 있는데 그것 중 하나가 캡슐화이다.
인터페이스 및 추상클래스 기반으로 구현하여 외부에는 인터페이스와 추상클래스만 노출되고 안의 데이터는 노출되지 않게하는 구현 은닉 기법, 객체의 구체적은 타입을 은닉하는 상위타입캐스팅 등의 방법이 있다.



 정보은닉을 하는 이유는 이와 같다.
-코드가 구체적인 것들(타입, 메소드, 구현)에 의존하는 것을 막아줌으로써 객체 간의 구체적인 결합도를 약화시켜 기능의 교체나 변경이 쉽도록 함.
- 동일한 타입의 다른 구현 객체들을 교체함으로써 동적 기능 변경이 가능함.
- 연동할 구체적인 구현이 없는 상태에서도 (인터페이스 만으로) 정확한 연동 코드의 생성이 가능함.

간단하게 말해서 기능의 수정/추가/교체를 가능하게 하기위한 기법이라고 할 수 있다.

5. 메소드 오버로딩, 클래스 오버라이딩
●오버로딩

같은 이름의 메소드를 여러 개 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술
만약 값을 리턴하는 getvalue()라는 메소드가 있다고 가정하고 매개변수의 유형을 다르게
-public void getvalue(int a)
-public void getvalue(string b) 
이렇게 정의 한다면 함수를 호출할 때 getvalue(int a); 이렇게 매개변수를 int형 변수로 주면  int형 매개변수를 가진 메소드를 호출한다.
오버로딩을 위해서는 매개변수의 개수나 변수형이 달라야 한다.
대표적으로 오버로딩을 사용한 코드가 바로 system.out.println이다. 우리가 뒤에 무슨값을 매개변수로 주어도 콘솔창에 출력되는 것이 이런 이유이다.

●오버라이딩

상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의 해서 사용한다.
상위클래스가 가진 메서드가 꼭 자식에게 필요한 기능으로 구현 되어있지 않을 수도 있다.
Car라는 상위클래스가 있다면 안에 speedup()이라는 속력을 올리는 메소드가 있다고 가정해 보자 생성되는 차량마다 가속력이 다를 것이다 아반떼는 비교적 올라가는 속도가 느릴 것 이고 포르쉐는 빠를 것이다. 이처럼 부모클래스의 메서드를 자신의 입맛에 맞게 사용 하는 것을 오버라이딩이라고 한다.


6. Exception 
●에러와 예외
exception이란 컴퓨터 시스템의 동작 도중 예기치 않았건 이상상태가 발생하여 수행중인 프로그램이 영향을 받는 것을 의미한다.
(error는 컴파일시 문법적인오류, 런타임시 오류같이 심각한 문제를 야기해 프로세스가 종료된다.)
이 예외에 대한 처리를 하는 것을 예외 처리라고 한다.

●예외 처리 방법
1.자바의 예외 처리는 예외가 발생한 메서드 내에서 직접 처리하는 방법
메서드 내에서 직접 처리할 경우 try ~catch문을 사용한다. 사용법은 아래와 같다.
try{
    예외 발생 가능성이 있는 문장들;
}catch(예외 타입1 매개변수명){
    예외타입1의 예외가 발생할 경우 처리 문장들;
}catch(예외 타입 n 매개변수명){
    예외타입 n의 예외가 발생할 경우 처리 문장들;
}finally{
    항상 수행할 필요가 있는 문장들;
}
catch 블록의 매개변수는 Throwable 클래스의 하위클래스 타입으로 선언되어야 한다.(예외와 에러를 상속해주는 클래스)
finally 블록은 써도 쓰지 않아도 되지만 마지막에 수행할 문장이 있다면 쓰는 것이 좋다.

try 문장 내에서 예외가 발생하면 catch문에서 잡아서 catch블록을 수행한다.

2.예외가 발생한 메소드를 호출한 곳으로 예외 객체를 넘겨주는 방법, 

static void callDriver() throws ClassNotFoundException{
        Class.forName("oracle.jdbc.driver.OracleDriver");
        System.out.println("완료");
    }

이렇게 메소드 선언부에 throws를 사용해 메소드를 호출한곳으로 예외를 넘겨줄 수 있다.

3.사용자 정의 예외를 생성하여 처리하는 방법이 있다.

사용자가 직접 Exception을 상속받은 클래스를 정의해서 예외 처리를 할 수 있다.
